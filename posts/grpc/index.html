<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://pokom.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pokom.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pokom.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://pokom.github.io/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://pokom.github.io/apple-touch-icon.png><meta name=description content><title>gRPC | Mark Poko</title><link rel=canonical href=https://pokom.github.io/posts/grpc/><meta property="og:url" content="https://pokom.github.io/posts/grpc/"><meta property="og:site_name" content="Mark Poko"><meta property="og:title" content="gRPC"><meta property="og:description" content="I’ve heard of gRPC for quite some time, ran many applications in my life as a platform engineer that had gRPC endpoints, but never directly contributed to it. gRPC is coming up more frequently now that I’m working as a backend engineer, and I feel like I need to dive deeper into the fundamentals. The code is intuitive enough to update existing handlers. But what happens if you need to create a new handler? Or if you need to update how the client is initialized?"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-23T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-23T00:00:00+00:00"><link rel=stylesheet href=/assets/combined.min.56b1873d8852f8a5a109abda36c1bfcde55cb48e5bcbe0d8c934a196a7dc374a.css media=all></head><body class=auto><div class=content><header><header><h1><a href=/>Mark Poko</a></h1><script>(function(){var e=document.createElement("script");e.src="https://unpkg.com/@grafana/faro-web-sdk@latest/dist/bundle/faro-web-sdk.iife.js",e.onload=()=>{window.GrafanaFaroWebSdk.initializeFaro({url:"https://faro-collector-prod-us-east-2.grafana.net/collect/ca670bb0217f3a5cc40ce1796b990ea8",app:{name:"markpoko.dev/blog",version:"1.0.0",environment:"production"}});var e=document.createElement("script");e.src="https://unpkg.com/@grafana/faro-web-tracing@latest/dist/bundle/faro-web-tracing.iife.js",e.onload=()=>{window.GrafanaFaroWebSdk.faro.instrumentations.add(new window.GrafanaFaroWebTracing.TracingInstrumentation)},document.head.appendChild(e)},document.head.appendChild(e)})()</script></header></header><main class=main><div class=breadcrumbs><a href=/>~</a><span class=breadcrumbs-separator>/</span><a href=/posts/>Posts</a><span class=breadcrumbs-separator>/</span>
<a href=/posts/grpc/>gRPC</a></div><div><article><header class=single-intro-container><h1 class=single-title>gRPC</h1><div class=single-subsummary><div><p class=single-date><time datetime=2025-07-23T00:00:00+00:00>July 23, 2025</time></p></div></div></header><div class=single-content><p>I&rsquo;ve heard of gRPC for quite some time, ran many applications in my life as a platform engineer that had gRPC endpoints, but never directly contributed to it.
gRPC is coming up more frequently now that I&rsquo;m working as a backend engineer, and I feel like I need to dive deeper into the fundamentals.
The code is intuitive enough to update existing handlers.
But what happens if you need to create a new handler?
Or if you need to update how <a href=github.com/grafana/synthetic-monitoring-agent/issues/738>the client is initialized</a>?</p><h2 class=heading id=what-is-grpc>What is gRPC?
<a class=anchor href=#what-is-grpc>#</a></h2><p>Taken directly from their <a href=grpc.io>website</a>:</p><blockquote><p>A high performance, open source universal RPC framework</p></blockquote><p>Okay, that does not help me in the slightest.
Wikipedia helped me a bit more with defining <a href=https://en.wikipedia.org/wiki/Remote_procedure_call>RPC</a>, which stands for a remote procedure call:</p><blockquote><p>In distributed computing, a remote procedure call (RPC) is when a computer program causes a procedure (subroutine) to execute in a different address space (commonly on another computer on a shared computer network), which is written as if it were a normal (local) procedure call, without the programmer explicitly writing the details for the remote interaction.</p></blockquote><p>This is still abstract to me, but it at least gets me a bit closer.
Given the context of how I&rsquo;ve seen gRPC used out in the wild, I interpret this as a way of executing code remotely without having the be aware of the network boundaries.
Why is this preferring over HTTP is not yet clear, but let&rsquo;s follow along.</p><p>So okay, gRPC is Google&rsquo;s high performance, open source, universal RPC framework.
Great, now how do I start using it?</p><h3 class=heading id=getting-started>Getting started
<a class=anchor href=#getting-started>#</a></h3><p>I won&rsquo;t rewrite their <a href=https://grpc.io/docs/languages/go/quickstart/>quickstart guide</a>, but one thing that&rsquo;s interesting is the need to install a protocol buffer compiler.
This immediately clues in that there&rsquo;s a tight coupling between gRPC and Protocol Buffers, but we&rsquo;ll come to that later.
After cloning the repo, you end up with the following tree:</p><pre tabindex=0><code> ~/dev/poko/grpc-go/examples/helloworld/ v1.74.2 tree
.
├── greeter_client
│   └── main.go
├── greeter_server
│   └── main.go
├── helloworld
│   ├── helloworld_grpc.pb.go
│   ├── helloworld.pb.go
│   └── helloworld.proto
└── README.md
</code></pre><p>At face value, the client and server look nearly identitical to what you would expect in any other network based application.
You have a server that is listening on a specific address and port waiting for connections.
The client is initialized to point towards the host and port the server is going to run on.
But there&rsquo;s <em>one</em> key bit that is different from a typical http application:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>c := pb.<span style=color:#666;font-weight:700;font-style:italic>NewGreeterClient</span>(conn)
</span></span></code></pre></div><p>This is the bit that is very different.
When looking at the code for <code>pb.NewGreaterClient</code>, this looks to be automatically generated:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#888;font-style:italic>// GreeterClient is the client API for Greeter service.</span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#888;font-style:italic>// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.</span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic>//
</span></span></span><span style=display:flex><span><span style=color:#888;font-style:italic>// The greeting service definition.</span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>type</span> GreeterClient <span style=font-weight:700;font-style:italic;text-decoration:underline>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#888;font-style:italic>// Sends a greeting</span>
</span></span><span style=display:flex><span>	<span style=color:#666;font-weight:700;font-style:italic>SayHello</span>(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, <span style=font-weight:700;text-decoration:underline>error</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>type</span> greeterClient <span style=font-weight:700;font-style:italic;text-decoration:underline>struct</span> {
</span></span><span style=display:flex><span>	cc grpc.ClientConnInterface
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>func</span> <span style=color:#666;font-weight:700;font-style:italic>NewGreeterClient</span>(cc grpc.ClientConnInterface) GreeterClient {
</span></span><span style=display:flex><span>	<span style=font-weight:700;text-decoration:underline>return</span> &amp;greeterClient{cc}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>func</span> (c *greeterClient) <span style=color:#666;font-weight:700;font-style:italic>SayHello</span>(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, <span style=font-weight:700;text-decoration:underline>error</span>) {
</span></span><span style=display:flex><span>	cOpts := <span style=font-weight:700;font-style:italic>append</span>([]grpc.CallOption{grpc.<span style=color:#666;font-weight:700;font-style:italic>StaticMethod</span>()}, opts...)
</span></span><span style=display:flex><span>	out := <span style=font-weight:700;font-style:italic>new</span>(HelloReply)
</span></span><span style=display:flex><span>	err := c.cc.<span style=color:#666;font-weight:700;font-style:italic>Invoke</span>(ctx, Greeter_SayHello_FullMethodName, in, out, cOpts...)
</span></span><span style=display:flex><span>	<span style=font-weight:700;text-decoration:underline>if</span> err != <span style=font-weight:700;text-decoration:underline>nil</span> {
</span></span><span style=display:flex><span>		<span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>nil</span>, err
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=font-weight:700;text-decoration:underline>return</span> out, <span style=font-weight:700;text-decoration:underline>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Okay, this isn&rsquo;t really clicking so maybe I should continue with the quickstart guide.
I followed the installation instructions and when running the protoc command, I get the following error:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>protoc --go_out=. --go_opt=<span style=color:#666;font-weight:700;font-style:italic>paths</span>=source_relative <span style=color:#666;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=color:#666;font-style:italic></span>    --go-grpc_out=. --go-grpc_opt=<span style=color:#666;font-weight:700;font-style:italic>paths</span>=source_relative <span style=color:#666;font-style:italic>\
</span></span></span><span style=display:flex><span><span style=color:#666;font-style:italic></span>    helloworld/helloworld.proto
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>protoc-gen-go: program not found or is not executable
</span></span><span style=display:flex><span>Please specify a program using absolute path or make sure the program is available in your PATH system variable
</span></span><span style=display:flex><span>--go_out: protoc-gen-go: Plugin failed with status code 1.
</span></span></code></pre></div><p>That&rsquo;s pretty annoying, as I have another one installed:</p><pre tabindex=0><code>which protoc-gen-go-grpc
/home/poko/go/bin/protoc-gen-go-grpc
</code></pre><p>So time to figure out where in the instructions things are broken.</p></div></article><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/posts/faro/>Faro</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/posts/arch/>One Month with Arch</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>